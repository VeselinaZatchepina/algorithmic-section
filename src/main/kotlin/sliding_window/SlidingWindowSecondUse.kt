package sliding_window
/*
Если нам надо найти количество подмассивов, которые удовлетворяют "требованию",
мы также можем использовать подход "Sliding window".

Ключевая идея: если нам надо найти количество подмассивов, думайте так:
"На каждом индексе: сколько "валидных" подмассивов заканчиваются на этом индексе"

Количество подмассивов, заканчивающихся на текущем индексе равно длине подмассива, достигшего этого индекса.

Пример: дан массив [10, 5, 2, 6]
Есть индекс 2 - позиция в массиве.
Массивы, заканчивающиеся на данном индексе: [10, 5, 2], [5, 2], [2] - что равно длине подмассива (3), достигшего индекса 2.
*/

/**
 * Задача:
 * Есть массив положительных целых чисел nums и число k.
 * Найти количество подмассивов в которых произведение всех элементов строго меньше k.
 *
 * Сложность алгоритма будет O(n).
 * По памяти O(1).
 */

fun main() {
    println(findSubarrayCount(listOf(10, 5, 2, 6), 100))
}

fun findSubarrayCount(nums: List<Int>, k: Int): Int {
    if (k <= 1) { // так как строго меньше k
        return 0
    }

    var left = 0
    var curr = 1
    var answer = 0

    for (right in nums.indices) {
        curr *= nums[right]
        while (left <= right && curr >= k) {
            curr /= nums[left]
            left++
        }

        answer += right - left + 1
    }

    return answer
}